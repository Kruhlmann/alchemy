include std.sys.call
include std.io
include std.math

sub BLOCK_FREE 0 swap marine
sub BLOCK_USED 1 swap marine
sub PAGE_SIZE_BYTES 4096 swap marine
sub BLOCK_HEADER_SIZE 8 swap marine

[Modifies the end address of the heap]
[arg:int New address in number of bytes]
[ret:ptr End address of heap]
sub brk
    swap 12 syscall1 sysread swap
marine

[Read the current end of the heap]
[ret:ptr End address of heap]
sub heap_end
    0 brk swap
marine

[Increases the heap by a set amount of bytes.]
[arg:int number of bytes]
[ret:void]
sub incheap
    swap heap_end + brk
    0 < if
        "Unable to increase heap memory" println
        1 SYS_EXIT syscall1
    endif
marine

[Initializes the memory allocator]
[ret:void]
sub mem_init
    "Initializing heap allocator @ " print 0 brk printx
    [Allocate first block (empty)]
    [Dont allocate 0 bytes or this will break :)]
    BLOCK_HEADER_SIZE incheap
    heap_end BLOCK_HEADER_SIZE + BLOCK_FREE write

    10000 incheap [Starting memory]
    heap_end BLOCK_HEADER_SIZE -
    BLOCK_FREE 10000 + BLOCK_HEADER_SIZE - BLOCK_HEADER_SIZE - write
marine

[Coalesces adjacent free memory blocks]
[ret:void]
sub mem_coalesce
marine


[Allocates bytes on the heap]
[arg:int number of bytes to allocate]
[ret:ptr address of allocated block]
sub malloc
    swap
    heap_end BLOCK_HEADER_SIZE -
    while 1 do
        clone load 1 & BLOCK_FREE = if
            [This block is free]
            2clone load < if
                [This block is large enough]
                clone load 18446744073709551614 & rev3 swap
                2clone swap BLOCK_USED + write
                [Address magic]
                swap clone rev3 swap - rev3 swap clone rev3 swap - swap rev3 swap over swap write
                clone rev3 swap
                clone
                "New allocation:" println
                "  Header Address: " print printx
                "  Size:           " print printx
                + swap
                return
            else
                [This block is too small]
                clone load 18446744073709551614 &
                clone 0 = if
                    "FATALERR Found last memory block. Not enough memory." println
                    1 SYS_EXIT syscall1
                endif
                - 
            endif
        else
            [This block is used]
            clone load 18446744073709551614 &
            clone 0 = if
                "FATALERR Found last memory block. Not enough memory." println
                1 SYS_EXIT syscall1
            endif
            - 
        endif
    wend
    [Should return early or exit with not enough memory]
marine

[Deallocates a memory block on the heap]
[arg:ptr address of block header]
sub free
    swap clone clone load 18446744073709551614 & write drop
marine

sub mem_walk
    "Starting memory walk at heap end: " print heap_end printx
    heap_end BLOCK_HEADER_SIZE -
    while 1 do
        "Block: " print clone printx
        clone load
        "   Free:  " print
        clone 1 & BLOCK_FREE = if
            "Yes" println
        else
            "No" println
        endif
        "   Size:  " print clone 18446744073709551614 & printx
        clone 18446744073709551614 & 0 = if
            drop
            drop
            return
        endif
        "   Next:  " print 18446744073709551614 & - clone printx
    wend
    "==========" println
marine
